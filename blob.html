<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> `.-':_,^=;+!r </title>
    <script src="p5.min.js"></script>
    <script src="p5.sound.min.js"></script>
    <script src="p5.vida.min.js"></script>
    <script>
        let vid;
        let myVida;
        let mic, fft;
        let kickThreshold = 10;
        let lastPeakTime = 0;
        const offset = 1000;
        let displayMode = 0;
        let isGray = false;
        let videoChangeInterval = 50000;
        let videoUrls = ['video_1.mp4', 'video_2.mp4', 'video_3.mp4', 'video_4.mp4'];
        let currentVideoIndex = 0;

        let color = [255, 255, 0];

        async function setup() {
            pixelDensity(1);
            createCanvas(windowWidth, windowHeight);
            textAlign(CENTER, CENTER);

            userStartAudio();
            mic = new p5.AudioIn();
            mic.start();
            fft = new p5.FFT(0.6, 256);
            fft.setInput(mic);

            currentVideoIndex = floor(random(0, videoUrls.length));
            await loadVideo();

            myVida = new Vida(this);
            myVida.progressiveBackgroundFlag = true;
            myVida.imageFilterFeedback = 0.85;
            myVida.imageFilterThreshold = 0.1;
            myVida.handleBlobsFlag = true;
            myVida.trackBlobsFlag = true;
            myVida.approximateBlobPolygonsFlag = false;
            myVida.normMinBlobMass = 0.0001;

            frameRate(30);
            background(0);

            setInterval(() => {
                switchVideo();
            }, videoChangeInterval);
        }

        async function loadVideo() {
            if (vid) vid.remove();
            vid = createVideo(videoUrls[currentVideoIndex]);
            vid.size(320, 240);
            vid.volume(0);
            vid.loop();
            vid.hide();

            vid.elt.onloadedmetadata = () => {
                let randomStartTime = random(0, vid.duration());
                vid.time(randomStartTime);
                console.log(`Video loaded: ${videoUrls[currentVideoIndex]} starting at ${randomStartTime} seconds`);
            };
        }

        function draw() {
            background(0);

            let bassEnergy = fft.getEnergy("bass");
            let bpm = map(bassEnergy, 0, 255, 60, 180);
            // let speed = map(bpm, 60, 180, 0.1, 2);
            // vid.speed(speed);

            let spectrum = fft.analyze();
            let kickEnergy = fft.getEnergy(20, 100);

            if (vid && vid.elt.readyState >= 2) {
                myVida.update(vid);
                image(vid, 0, 0, width, height);

                if (kickEnergy > kickThreshold && millis() - lastPeakTime > offset) {
                    displayMode = (displayMode + 1) % 5;
                    lastPeakTime = millis();
                }

                drawBlobs();
            }
        }

        function drawBlobs() {
            let blobs = myVida.getBlobs();
            let points = [];

            for (let i = 0; i < blobs.length; i++) {
                let b = blobs[i];

                let rectX = b.normRectX * width;
                let rectY = b.normRectY * height;
                let rectW = b.normRectW * width;
                let rectH = b.normRectH * height;

                let massX = b.normMassCenterX * width;
                let massY = b.normMassCenterY * height;

                points.push({ x: massX, y: massY });


                switch (displayMode) {
                    case 0:
                        noFill();
                        stroke(...color);
                        rect(rectX, rectY, rectW, rectH);
                        noStroke();
                        fill(...color);
                        textSize(8);
                        text(`ID: ${b.id} X:${int(rectX)} Y:${int(rectY)}`, rectX - 20, rectY - 10, 50);
                        break;
                    case 1:
                        noStroke();
                        fill(...color);
                        textSize(6);
                        text(`ID: ${b.id} X:${int(rectX)} Y:${int(rectY)}`, rectX, rectY - 5);
                        break;
                    case 2:
                        noStroke();
                        fill(...color);
                        ellipse(massX, massY, 5, 5);
                        textSize(6);
                        text(`ID: ${b.id} X:${int(rectX)} Y:${int(rectY)}`, rectX, rectY - 5);
                        break;
                    case 3:
                        noStroke();
                        fill(...color);
                        ellipse(massX, massY, 5, 5);
                        textSize(6);
                        text(`ID: ${b.id} X:${int(rectX)} Y:${int(rectY)}`, rectX, rectY - 5);
                        break;
                    case 4:
                        noFill();
                        stroke(...color);
                        rect(rectX, rectY, rectW, rectH);

                        line(rectX, rectY, rectX + rectW, rectY + rectH);
                        line(rectX + rectW, rectY, rectX, rectY + rectH);

                        noStroke();
                        fill(...color);
                        textSize(8);
                        text(`ID: ${b.id} X:${int(rectX)} Y:${int(rectY)}`, rectX - 20, rectY - 10, 50);

                }
            }

            // if (displayMode === 2) {
            //     stroke(...color);
            //     for (let i = 0; i < points.length / 4; i++) {
            //         for (let j = i + 1; j < points.length; j++) {
            //             line(points[i].x, points[i].y, points[j].x, points[j].y);
            //         }
            //     }
            // }
            // console.log(points.length)
            if (displayMode === 2 && points.length <= 30) {
                stroke(...color);
                // strokeWeight(.5)
                noFill();

                for (let i = 0; i < points.length / 3; i++) {
                    for (let j = i + 1; j < points.length; j++) {
                        let p1 = points[i];
                        let p2 = points[j];
                        let controlX1 = (p1.x + p2.x) / 2 + random(-250, 250);
                        let controlY1 = (p1.y + p2.y) / 2 + random(-250, 250);

                        let controlX2 = (p1.x + p2.x) / 2 + random(-250, 250);
                        let controlY2 = (p1.y + p2.y) / 2 + random(-250, 250);

                        bezier(p1.x, p1.y, controlX1, controlY1, controlX2, controlY2, p2.x, p2.y);
                    }
                }
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }

        function switchVideo() {
            currentVideoIndex = (currentVideoIndex + 1) % videoUrls.length;
            loadVideo();
        }

        function mousePressed() {
            switchVideo();
            if (vid) {
                vid.play();
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            document.getElementById("threshold-slider").addEventListener("input", (event) => {
                kickThreshold = parseInt(event.target.value, 10);
                document.getElementById("threshold-value").textContent = kickThreshold;
            });
        });
    </script>
</head>

<header>
    <a href="datamosh.html">Datamosh</a>
    <a href="barcode.html">Barcode</a>
    <a href="blob.html">Detection</a>
    <a href="vol.html">Volume</a>
    <a href="ascii.html">Ascii</a>
    <a href="grid.html">Video Grid</a>
    <span id="controls">
        |
        <label for="threshold-slider" style="color: white;">Threshold: <span id="threshold-value">100</span></label>
        <input type="range" id="threshold-slider" min="10" max="2000" step="1" value="100" />
    </span>
</header>

<body></body>

<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, Helvetica, sans-serif;
    }

    header {
        background: black;
        color: white;
        text-align: center;
        padding: 10px 0;
        position: absolute;
    }

    header a {
        margin: 0 10px;
        color: white;
        text-decoration: none;
    }
</style>

</html>