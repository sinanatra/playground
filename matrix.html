<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>`.-':_,^=;+!r</title>
    <script src="p5.min.js"></script>
    <script src="p5.sound.min.js"></script>
    <script>
      let mic, fft;
      let cols = 100,
        rows = 50;
      let cellW, cellH;
      let colAmp = [];
      let seed = 0;
      let strobe = 0;
      let glyphs = [];
      function setup() {
        pixelDensity(1);
        createCanvas(windowWidth, windowHeight);
        noStroke();
        textAlign(CENTER, CENTER);
        textFont("monospace");
        userStartAudio();
        mic = new p5.AudioIn();
        mic.start();
        fft = new p5.FFT(0.8, 512);
        fft.setInput(mic);
        glyphs = "01▌▐░▒▓█▄▀┘┐┌└│─┼╳•×+−=≡◊◌○●◼◻◾◽⬛⬜⬤⟁⧫⨯◬◮◯◹◾◱◰⧖⧗⧙⧚".split(
          ""
        );
        computeCell();
      }
      function computeCell() {
        cellW = width / cols;
        cellH = height / rows;
        textSize(cellH * 0.9);
      }
      function draw() {
        background(0);
        const spec = fft.analyze();
        colAmp.length = cols;
        for (let c = 0; c < cols; c++) {
          const a0 = floor(map(c, 0, cols, 0, spec.length * 0.9));
          const a1 = min(a0 + floor(spec.length / cols) + 1, spec.length - 1);
          let s = 0;
          for (let i = a0; i <= a1; i++) s += spec[i];
          colAmp[c] = s / (a1 - a0 + 1 || 1) / 255;
        }
        strobe = (strobe + 1) %120;
        const invert = strobe < 2;
        for (let y = 0; y < rows; y++) {
          const ry = y / rows;
          for (let x = 0; x < cols; x++) {
            const cx = x * cellW + cellW * 0.5;
            const cy = y * cellH + cellH * 0.5;
            const a = colAmp[x] || 0;
            const t = millis() * 0.001;
            const n = fract(
              sin((x + 1.618) * (y + 2.414) + t * 7.0 + seed * 0.221) *
                43758.5453
            );
            const p = constrain(a * 1.5 + ry * 0.15 + (n - 0.5) * 0.3, 0, 1);
            const gIndex = floor(map(p, 0, 1, 0, glyphs.length - 1));
            const glyph = glyphs[gIndex];
            const cVal = p * 255;
            if (invert) {
              fill(255 - cVal);
              text(glyph, cx, cy);
            } else {
              fill(cVal);
              text(glyph, cx, cy);
            }
          }
        }
        seed += 0.002;
        if (frameCount % 180 === 0) {
          cols = random([48, 60, 72, 84, 96]);
          rows = random([36, 42, 48, 60]);
          computeCell();
        }
        if (frameCount % 9 === 0) {
          push();
          blendMode(ADD);
          fill(255, random(5, 20));
          rect(width * 0.5, random(height), width, 1);
          pop();
        }
      }
      function fract(v) {
        return v - Math.floor(v);
      }
      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        computeCell();
      }
    </script>
  </head>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</html>
